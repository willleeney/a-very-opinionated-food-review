import { describe, it, expect, vi, beforeEach } from 'vitest'
import { supabase } from '../lib/supabase'

// Test data
const mockOrgId = '11111111-1111-1111-1111-111111111111'
const mockAdminUserId = 'admin-user-id'

const mockInvite = {
  id: 'invite-1',
  organisation_id: mockOrgId,
  email: 'invitee@example.com',
  token: 'test-invite-token-123',
  invited_by: mockAdminUserId,
  created_at: '2026-01-01T00:00:00Z',
  expires_at: '2027-01-08T00:00:00Z', // Future date
}

const mockExpiredInvite = {
  ...mockInvite,
  id: 'invite-2',
  expires_at: '2023-01-01T00:00:00Z', // Past date
}

describe('Organisation Invites', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('Admin creating invites', () => {
    it('should allow admin to create an invite', async () => {
      const mockInsert = vi.fn().mockResolvedValue({ data: mockInvite, error: null })

      vi.mocked(supabase.from).mockReturnValue({
        insert: mockInsert,
      } as any)

      const { data, error } = await supabase
        .from('organisation_invites')
        .insert({
          organisation_id: mockOrgId,
          email: 'invitee@example.com',
          invited_by: mockAdminUserId,
        })

      expect(supabase.from).toHaveBeenCalledWith('organisation_invites')
      expect(mockInsert).toHaveBeenCalledWith({
        organisation_id: mockOrgId,
        email: 'invitee@example.com',
        invited_by: mockAdminUserId,
      })
    })

    it('should generate a unique token for the invite', async () => {
      const mockInsert = vi.fn().mockReturnThis()
      const mockSelect = vi.fn().mockReturnThis()
      const mockSingle = vi.fn().mockResolvedValue({ data: mockInvite, error: null })

      vi.mocked(supabase.from).mockReturnValue({
        insert: mockInsert,
        select: mockSelect,
        single: mockSingle,
      } as any)

      const { data } = await supabase
        .from('organisation_invites')
        .insert({
          organisation_id: mockOrgId,
          email: 'invitee@example.com',
          invited_by: mockAdminUserId,
        })
        .select()
        .single()

      // Token is generated by the database via default value
      expect(data?.token).toBeDefined()
      expect(data?.token.length).toBeGreaterThan(0)
    })
  })

  describe('User accepting invite via token', () => {
    it('should find invite by token', async () => {
      const mockSelect = vi.fn().mockReturnThis()
      const mockEq = vi.fn().mockReturnThis()
      const mockSingle = vi.fn().mockResolvedValue({ data: mockInvite, error: null })

      vi.mocked(supabase.from).mockReturnValue({
        select: mockSelect,
        eq: mockEq,
        single: mockSingle,
      } as any)

      const { data, error } = await supabase
        .from('organisation_invites')
        .select('*')
        .eq('token', 'test-invite-token-123')
        .single()

      expect(data).toEqual(mockInvite)
      expect(error).toBeNull()
    })

    it('should add user as member when accepting invite', async () => {
      const mockInsert = vi.fn().mockResolvedValue({ data: null, error: null })

      vi.mocked(supabase.from).mockReturnValue({
        insert: mockInsert,
      } as any)

      const { error } = await supabase
        .from('organisation_members')
        .insert({
          organisation_id: mockOrgId,
          user_id: 'new-user-id',
          role: 'member',
        })

      expect(supabase.from).toHaveBeenCalledWith('organisation_members')
      expect(error).toBeNull()
    })

    it('should delete invite after acceptance', async () => {
      const mockDelete = vi.fn().mockReturnThis()
      const mockEq = vi.fn().mockResolvedValue({ data: null, error: null })

      vi.mocked(supabase.from).mockReturnValue({
        delete: mockDelete,
        eq: mockEq,
      } as any)

      const { error } = await supabase
        .from('organisation_invites')
        .delete()
        .eq('id', mockInvite.id)

      expect(supabase.from).toHaveBeenCalledWith('organisation_invites')
      expect(mockDelete).toHaveBeenCalled()
    })
  })

  describe('Expired invite handling', () => {
    it('should detect expired invites', () => {
      const now = new Date()
      const expiresAt = new Date(mockExpiredInvite.expires_at)

      expect(expiresAt < now).toBe(true)
    })

    it('should not accept expired invites', async () => {
      // The application logic should check expiration before accepting
      const isExpired = (invite: typeof mockExpiredInvite) => {
        if (!invite.expires_at) return false
        return new Date(invite.expires_at) < new Date()
      }

      expect(isExpired(mockExpiredInvite)).toBe(true)
      expect(isExpired(mockInvite)).toBe(false) // Non-expired invite
    })
  })

  describe('Non-admin cannot create invites', () => {
    it('should not allow regular member to create invite', async () => {
      // This would be enforced by RLS policies
      const mockInsert = vi.fn().mockResolvedValue({
        data: null,
        error: { message: 'Row level security policy violation' }
      })

      vi.mocked(supabase.from).mockReturnValue({
        insert: mockInsert,
      } as any)

      const { error } = await supabase
        .from('organisation_invites')
        .insert({
          organisation_id: mockOrgId,
          email: 'invitee@example.com',
          invited_by: 'regular-member-id',
        })

      expect(error).toBeDefined()
    })
  })

  describe('Cancelling invites', () => {
    it('should allow admin to cancel pending invite', async () => {
      const mockDelete = vi.fn().mockReturnThis()
      const mockEq = vi.fn().mockResolvedValue({ data: null, error: null })

      vi.mocked(supabase.from).mockReturnValue({
        delete: mockDelete,
        eq: mockEq,
      } as any)

      const { error } = await supabase
        .from('organisation_invites')
        .delete()
        .eq('id', mockInvite.id)

      expect(error).toBeNull()
    })
  })
})
